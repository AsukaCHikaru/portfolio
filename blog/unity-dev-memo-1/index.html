<!DOCTYPE html><html lang="en"><head>
    <title>Unity Dev Memo (1) | Asuka Wang</title>
    <meta name="description" content="關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。">
    <meta name="author" content="Asuka Wang">
    <meta property="og:title" content="Unity Dev Memo (1) | Asuka Wang">
    <meta property="og:description" content="關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。">
  
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="module" src="/index.js" async=""></script>
    <link rel="stylesheet" href="/subfont/fonts-cae88660cc.css">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/modern-normalize.css">
    
    
    <link rel="preload" href="/fonts/subset_extended_latin_NotoSerifJP_ExtraLight.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    
    
    
    
    
    
  </head>
  <body>
    <div id="root"><div><div class="site_container grid"><header class="site-header"><div class="header-content"><div class="header_left_content"><nav><a href="/blog">blog</a><a href="/about">about</a><a href="/blog/feed.xml">rss</a></nav><button type="button" class="frontpage-header-menu-button">menu</button></div><h1><a href="/">ASUKA WANG</a></h1><div class="header_right_content"></div></div><div class="header-divider"></div></header><main class="grid"><div class="post-page-header_container"><h1>Unity Dev Memo (1)</h1><h2>關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。</h2><p>March 8, 2020</p></div><article class="post-page-content grid"><p>在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。</p><h1>Object movement</h1><p>在 Unity ，要讓一個物體移動有三種方式：</p><ul><li><code>Transform.position</code></li><li><code>Rigidbody.AddForce()</code></li><li><code>CharacterController.Move()</code></li></ul><h2>Transform.position</h2><p><code>Transform</code> 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。</p><p>使用 <code>Transform.position</code> 調整物體位置的語法像是這樣：</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#076678">Transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">position</span><span style="color:#427B58"> =</span><span style="color:#427B58"> new</span><span style="color:#B57614"> Vector3</span><span style="color:#7C6F64">(</span><span style="color:#8F3F71">0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 1</span><span style="color:#7C6F64">);</span></span></code></pre></div><p>在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#B57614">Vector3</span><span style="color:#427B58"> objectPos</span><span style="color:#427B58"> =</span><span style="color:#076678"> Transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">position</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#076678">Transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">position</span><span style="color:#427B58"> =</span><span style="color:#427B58"> new</span><span style="color:#B57614"> Vector3</span><span style="color:#7C6F64">(</span><span style="color:#076678">objetPos</span><span style="color:#7C6F64">.</span><span style="color:#076678">x</span><span style="color:#7C6F64">,</span><span style="color:#076678"> objectPos</span><span style="color:#7C6F64">.</span><span style="color:#076678">y</span><span style="color:#7C6F64">,</span><span style="color:#076678"> objectPos</span><span style="color:#7C6F64">.</span><span style="color:#076678">z</span><span style="color:#427B58"> +</span><span style="color:#8F3F71"> 1</span><span style="color:#7C6F64">);</span></span></code></pre></div><p>這樣就能讓物體朝向 Z 方向移動 1 單位。</p><p>使用 <code>Transform.position</code> 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。</p><h2>Rigidbody.Addforce</h2><p>來看看官方說明手冊的對 Rigidbody 的第一句說明：</p><blockquote><span>Control of an object's position through physics simulation.</span></blockquote><p>Rigidbody 是從物理面上控制物體。 <code>AddForce</code> 就是基於一個 Vector3 的角度給予外力。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#076678">Rigidbody</span><span style="color:#7C6F64">.</span><span style="color:#79740E">AddForce</span><span style="color:#7C6F64">(</span><span style="color:#427B58">new</span><span style="color:#B57614"> Vector3</span><span style="color:#7C6F64">(</span><span style="color:#8F3F71">0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 10</span><span style="color:#7C6F64">));</span></span></code></pre></div><p>這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。</p><p>由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。</p><h2>CharacterController.Move</h2><p>一樣來看看官方手冊的說明：</p><blockquote><span>A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions.</span></blockquote><p>CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#076678">CharacterController</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Move</span><span style="color:#7C6F64">(</span><span style="color:#427B58">new</span><span style="color:#B57614"> Vector3</span><span style="color:#7C6F64">(</span><span style="color:#8F3F71">0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 0</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 1</span><span style="color:#7C6F64">));</span></span></code></pre></div><p><code>CharacterController.Move</code> 比起 <code>Rigidbody.AddForce</code> 更加平滑，且會受碰撞影響，比起 <code>Transform.position</code> 更加自然。</p><p>另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。</p><h1>Execution Order</h1><p>Unity 新增 script 的初始範本都包含兩個函數： <code>Start()</code> 與 <code>Update()</code> 。這兩個函數都是腳本系統的核心之一。</p><h2>Start()</h2><p>Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。</p><h2>Update()</h2><p>Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。</p><h2>FixedUpdate()</h2><p>FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。</p><h2>LateUpdate()</h2><p>LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。</p><h1>Hitbox and hurtbox</h1><p>3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 <code>Physics.OverlapBox()</code> 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。</p><p>首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 <code>Is Trigger</code> 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下：</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#AF3A03">public</span><span style="color:#AF3A03"> class</span><span style="color:#B57614"> AttackController</span><span style="color:#7C6F64"> :</span><span style="color:#B57614"> MonoBehaviour</span></span>
<span class="line"><span style="color:#7C6F64">{</span></span>
<span class="line"><span style="color:#AF3A03">		public</span><span style="color:#B57614"> Collider</span><span style="color:#427B58"> Hitbox</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#AF3A03">		public</span><span style="color:#9D0006"> int</span><span style="color:#427B58"> ATK</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#AF3A03">		private</span><span style="color:#B57614"> List</span><span style="color:#7C6F64">&lt;</span><span style="color:#B57614">GameObject</span><span style="color:#7C6F64">&gt;</span><span style="color:#427B58"> hitEnemies</span><span style="color:#427B58"> =</span><span style="color:#427B58"> new</span><span style="color:#B57614"> List</span><span style="color:#7C6F64">&lt;</span><span style="color:#B57614">GameObject</span><span style="color:#7C6F64">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">		void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64">()</span></span>
<span class="line"><span style="color:#7C6F64">		{</span></span>
<span class="line"><span style="color:#79740E">        DetectAttack</span><span style="color:#7C6F64">(</span><span style="color:#427B58">Hitbox</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#7C6F64">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AF3A03">		public</span><span style="color:#9D0006"> void</span><span style="color:#79740E"> ClearHitEnemyList</span><span style="color:#7C6F64">()</span></span>
<span class="line"><span style="color:#7C6F64">		{</span></span>
<span class="line"><span style="color:#076678">		    hitEnemies</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Clear</span><span style="color:#7C6F64">();</span></span>
<span class="line"><span style="color:#7C6F64">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">		void</span><span style="color:#79740E"> DetectAttack</span><span style="color:#7C6F64">(</span><span style="color:#B57614">Collider</span><span style="color:#B57614"> hitbox</span><span style="color:#7C6F64">)</span></span>
<span class="line"><span style="color:#7C6F64">		{</span></span>
<span class="line"><span style="color:#B57614">		    Collider</span><span style="color:#7C6F64">[]</span><span style="color:#427B58"> hurtboxes</span><span style="color:#427B58"> =</span><span style="color:#076678"> Physics</span><span style="color:#7C6F64">.</span><span style="color:#79740E">OverlapBox</span><span style="color:#7C6F64">(</span></span>
<span class="line"><span style="color:#076678">		        hitbox</span><span style="color:#7C6F64">.</span><span style="color:#076678">bounds</span><span style="color:#7C6F64">.</span><span style="color:#076678">center</span><span style="color:#7C6F64">,</span><span style="color:#427B58"> //</span><span style="color:#427B58"> 中心點</span></span>
<span class="line"><span style="color:#076678">		        hitbox</span><span style="color:#7C6F64">.</span><span style="color:#076678">bounds</span><span style="color:#7C6F64">.</span><span style="color:#076678">extents</span><span style="color:#7C6F64">,</span><span style="color:#427B58"> //</span><span style="color:#427B58"> 三維尺寸</span></span>
<span class="line"><span style="color:#076678">		        hitbox</span><span style="color:#7C6F64">.</span><span style="color:#076678">transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">rotation</span><span style="color:#7C6F64">,</span><span style="color:#427B58"> //</span><span style="color:#427B58"> 三維角度</span></span>
<span class="line"><span style="color:#076678">		        LayerMask</span><span style="color:#7C6F64">.</span><span style="color:#79740E">GetMask</span><span style="color:#7C6F64">(</span><span style="color:#7C6F64">"</span><span style="color:#79740E">{INSERT LAYER NAME}</span><span style="color:#7C6F64">"</span><span style="color:#7C6F64">)</span><span style="color:#427B58"> //</span><span style="color:#427B58"> 指定對象</span><span style="color:#427B58"> layer</span></span>
<span class="line"><span style="color:#7C6F64">		    );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#928374;font-style:italic">				// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體</span></span>
<span class="line"><span style="color:#9D0006">		    foreach</span><span style="color:#7C6F64"> (</span><span style="color:#B57614">Collider</span><span style="color:#427B58"> hurtbox</span><span style="color:#9D0006"> in</span><span style="color:#427B58"> hurtboxes</span><span style="color:#7C6F64">)</span></span>
<span class="line"><span style="color:#7C6F64">		    {</span></span>
<span class="line"><span style="color:#B57614">		        GameObject</span><span style="color:#427B58"> enemy</span><span style="color:#427B58"> =</span><span style="color:#076678"> hurtbox</span><span style="color:#7C6F64">.</span><span style="color:#076678">gameObject</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">		        if</span><span style="color:#7C6F64"> (</span><span style="color:#9D0006">!</span><span style="color:#076678">hitEnemies</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Contains</span><span style="color:#7C6F64">(</span><span style="color:#427B58">enemy</span><span style="color:#7C6F64">))</span></span>
<span class="line"><span style="color:#7C6F64">		        {</span></span>
<span class="line"><span style="color:#076678">		            hitEnemies</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Add</span><span style="color:#7C6F64">(</span><span style="color:#427B58">enemy</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#076678">		            enemy</span><span style="color:#7C6F64">.</span><span style="color:#79740E">doAnythingYouWant</span><span style="color:#7C6F64">(</span><span style="color:#427B58">..</span><span style="color:#3C3836">.</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#7C6F64">		        }</span></span>
<span class="line"><span style="color:#7C6F64">		    }</span></span>
<span class="line"><span style="color:#7C6F64">		}</span></span>
<span class="line"><span style="color:#7C6F64">}</span></span></code></pre></div><p>我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 <code>ClearHitEnemyList</code> 清空列表即可。</p><p>最後的 <code>enemy</code> 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 <code>.SendMessageUpwards("{INSERT FUNC NAME}", {INSERT FUNC PARAM})</code> 。這個函數可以向上呼叫該腳本父物件的其他函數。</p></article></main><footer class="site-footer_container">Asuka Wang © <!-- -->2025</footer></div></div></div><script>window.__STATIC_PROPS__ = {"blog":{"post":{"metadata":{"title":"Unity Dev Memo (1)","description":"關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。","publishedAt":"2020-03-08","pathname":"unity-dev-memo-1","category":"note","topic":"game development","language":"zh-TW","featured":false},"content":[{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。"}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Object movement"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"在 Unity ，要讓一個物體移動有三種方式："}]},{"type":"list","ordered":false,"items":[{"type":"listItem","body":[{"type":"textBody","style":"code","value":"Transform.position"}]},{"type":"listItem","body":[{"type":"textBody","style":"code","value":"Rigidbody.AddForce()"}]},{"type":"listItem","body":[{"type":"textBody","style":"code","value":"CharacterController.Move()"}]}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Transform.position"}]},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"Transform"},{"type":"textBody","style":"plain","value":" 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"使用 "},{"type":"textBody","style":"code","value":"Transform.position"},{"type":"textBody","style":"plain","value":" 調整物體位置的語法像是這樣："}]},{"type":"code","lang":"csharp","body":"Transform.position = new Vector3(0, 0, 1);"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。"}]},{"type":"code","lang":"csharp","body":"Vector3 objectPos = Transform.position;\nTransform.position = new Vector3(objetPos.x, objectPos.y, objectPos.z + 1);"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"這樣就能讓物體朝向 Z 方向移動 1 單位。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"使用 "},{"type":"textBody","style":"code","value":"Transform.position"},{"type":"textBody","style":"plain","value":" 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Rigidbody.Addforce"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"來看看官方說明手冊的對 Rigidbody 的第一句說明："}]},{"type":"quote","body":[{"type":"textBody","style":"plain","value":"Control of an object's position through physics simulation."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Rigidbody 是從物理面上控制物體。 "},{"type":"textBody","style":"code","value":"AddForce"},{"type":"textBody","style":"plain","value":" 就是基於一個 Vector3 的角度給予外力。"}]},{"type":"code","lang":"csharp","body":"Rigidbody.AddForce(new Vector3(0, 0, 10));"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"CharacterController.Move"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"一樣來看看官方手冊的說明："}]},{"type":"quote","body":[{"type":"textBody","style":"plain","value":"A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。"}]},{"type":"code","lang":"csharp","body":"CharacterController.Move(new Vector3(0, 0, 1));"},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"CharacterController.Move"},{"type":"textBody","style":"plain","value":" 比起 "},{"type":"textBody","style":"code","value":"Rigidbody.AddForce"},{"type":"textBody","style":"plain","value":" 更加平滑，且會受碰撞影響，比起 "},{"type":"textBody","style":"code","value":"Transform.position"},{"type":"textBody","style":"plain","value":" 更加自然。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。"}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Execution Order"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Unity 新增 script 的初始範本都包含兩個函數： "},{"type":"textBody","style":"code","value":"Start()"},{"type":"textBody","style":"plain","value":" 與 "},{"type":"textBody","style":"code","value":"Update()"},{"type":"textBody","style":"plain","value":" 。這兩個函數都是腳本系統的核心之一。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Start()"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Update()"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"FixedUpdate()"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。"}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"LateUpdate()"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。"}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Hitbox and hurtbox"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 "},{"type":"textBody","style":"code","value":"Physics.OverlapBox()"},{"type":"textBody","style":"plain","value":" 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 "},{"type":"textBody","style":"code","value":"Is Trigger"},{"type":"textBody","style":"plain","value":" 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下："}]},{"type":"code","lang":"csharp","body":"public class AttackController : MonoBehaviour\n{\n\t\tpublic Collider Hitbox;\n\t\tpublic int ATK;\n\t\tprivate List\u003cGameObject\u003e hitEnemies = new List\u003cGameObject\u003e();\n\n\t\tvoid Update()\n\t\t{\n        DetectAttack(Hitbox);\n\t\t}\n\n\t\tpublic void ClearHitEnemyList()\n\t\t{\n\t\t    hitEnemies.Clear();\n\t\t}\n\n\t\tvoid DetectAttack(Collider hitbox)\n\t\t{\n\t\t    Collider[] hurtboxes = Physics.OverlapBox(\n\t\t        hitbox.bounds.center, // 中心點\n\t\t        hitbox.bounds.extents, // 三維尺寸\n\t\t        hitbox.transform.rotation, // 三維角度\n\t\t        LayerMask.GetMask(\"{INSERT LAYER NAME}\") // 指定對象 layer\n\t\t    );\n\n\t\t\t\t// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體\n\t\t    foreach (Collider hurtbox in hurtboxes)\n\t\t    {\n\t\t        GameObject enemy = hurtbox.gameObject;\n\t\t        if (!hitEnemies.Contains(enemy))\n\t\t        {\n\t\t            hitEnemies.Add(enemy);\n\t\t            enemy.doAnythingYouWant(...);\n\t\t        }\n\t\t    }\n\t\t}\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 "},{"type":"textBody","style":"code","value":"ClearHitEnemyList"},{"type":"textBody","style":"plain","value":" 清空列表即可。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"最後的 "},{"type":"textBody","style":"code","value":"enemy"},{"type":"textBody","style":"plain","value":" 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 "},{"type":"textBody","style":"code","value":".SendMessageUpwards(\"{INSERT FUNC NAME}\", {INSERT FUNC PARAM})"},{"type":"textBody","style":"plain","value":" 。這個函數可以向上呼叫該腳本父物件的其他函數。"}]}]}},"lastUpdated":"2025-06-26"}</script>
  

<script>(function(){var el=document.createElement('link');el.href='/subfont/fallback-f0092a2883.css';el.rel='stylesheet';document.body.appendChild(el)}())</script><noscript><link rel="stylesheet" href="/subfont/fallback-f0092a2883.css"></noscript></body></html>