<!DOCTYPE html><html lang="en"><head>
    <title>Unity Dev Memo (2) | Asuka Wang</title>
    <meta name="description" content="關於 Unity3D 內 raycast 的研究筆記。">
    <meta name="author" content="Asuka Wang">
    <meta property="og:title" content="Unity Dev Memo (2) | Asuka Wang">
    <meta property="og:description" content="關於 Unity3D 內 raycast 的研究筆記。">
  
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="module" src="/index.js" async=""></script>
    <link rel="stylesheet" href="/subfont/fonts-b1d946782a.css">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/modern-normalize.css">
    
    
    <link rel="preload" href="/fonts/subset_extended_latin_NotoSerifJP_ExtraLight.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    
    
    
    
    
  </head>
  <body>
    <div id="root"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-1_1.png"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-1_2.png"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-2_3.gif"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-2_4.gif"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-2_5 1.gif"><link rel="preload" as="image" href="/public/images/blog/unity-dev-memo-2_6.gif"><div><div class="site_container grid"><nav class="site-header_grid-wrapper"><div class="site-header_container"><div><a href="/blog">blog</a><a href="/about">about</a></div><a href="/">ASUKA WANG</a></div><div class="site-header_divider" role="presentation"></div></nav><main class="grid"><div class="post-page-header_container"><h1>Unity Dev Memo (2)</h1><h2>關於 Unity3D 內 raycast 的研究筆記。</h2><p>October 4, 2020</p></div><article class="post-page-content grid"><h2>Raycast</h2><p>在使用滑鼠的 3D 遊戲中，幾乎與任何物件互動都需要使用滑鼠，判斷玩家游標的位置自然是非常重要且基礎的技術。然而相對 3D 世界的三維座標，存在於螢幕上的游標只有二維座標的 X 軸與 Y 軸兩個數據代表位置，這使得在遊戲世界中精準定位游標位置變得困難。</p><p>不過，大多數想要在遊戲中取得游標位置時，都是為了與存在該位置的物件互動。這個物件就能成為定位游標的輔助工具，只要計算從玩家視角中的游標，是否真正與遊戲世界中的該物件重合即可。</p><p>具體來說，這個判斷方式是從攝影機朝向滑鼠的二維座標射出一道直線，並判斷該射線所相交的物件。</p><h3>Plane.Raycast</h3><p>先從這個技術的最基本實作，也就是判斷滑鼠在純平面上的座標開始。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> UnityEngine</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AF3A03">public</span><span style="color:#AF3A03"> class</span><span style="color:#B57614"> GetMousePos</span><span style="color:#7C6F64"> :</span><span style="color:#B57614"> MonoBehaviour</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">    Plane</span><span style="color:#427B58"> plane</span><span style="color:#427B58"> =</span><span style="color:#427B58"> new</span><span style="color:#B57614"> Plane</span><span style="color:#7C6F64"> (</span><span style="color:#076678">Vector3</span><span style="color:#7C6F64">.</span><span style="color:#076678">up</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 0</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#B57614">    Camera</span><span style="color:#427B58"> camera</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Vector3</span><span style="color:#427B58"> mousePos</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Start</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">        camera</span><span style="color:#427B58"> =</span><span style="color:#076678"> Camera</span><span style="color:#7C6F64">.</span><span style="color:#076678">main</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#9D0006">        float</span><span style="color:#427B58"> distance</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">        Ray</span><span style="color:#427B58"> ray</span><span style="color:#427B58"> =</span><span style="color:#076678"> camera</span><span style="color:#7C6F64">.</span><span style="color:#79740E">ScreenPointToRay</span><span style="color:#7C6F64">(</span><span style="color:#076678">Input</span><span style="color:#7C6F64">.</span><span style="color:#076678">mousePosition</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#9D0006">        if</span><span style="color:#7C6F64">(</span><span style="color:#076678">plane</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Raycast</span><span style="color:#7C6F64">(</span><span style="color:#427B58">ray</span><span style="color:#7C6F64">,</span><span style="color:#AF3A03"> out</span><span style="color:#427B58"> distance</span><span style="color:#7C6F64">)){</span></span>
<span class="line"><span style="color:#427B58">            mousePos</span><span style="color:#427B58"> =</span><span style="color:#076678"> ray</span><span style="color:#7C6F64">.</span><span style="color:#79740E">GetPoint</span><span style="color:#7C6F64">(</span><span style="color:#427B58">distance</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#7C6F64">        }</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"><span style="color:#7C6F64">}</span></span></code></pre></div><p>一行一行解讀：</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#B57614">Plane</span><span style="color:#427B58"> plane</span><span style="color:#427B58"> =</span><span style="color:#427B58"> new</span><span style="color:#B57614"> Plane</span><span style="color:#7C6F64"> (</span><span style="color:#076678">Vector3</span><span style="color:#7C6F64">.</span><span style="color:#076678">up</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 0</span><span style="color:#7C6F64">);</span></span></code></pre></div><p>從官方文件 <a href="https://docs.unity3d.com/ScriptReference/Plane-ctor.html" target="_blank" rel="noopener noreferrer">https://docs.unity3d.com/ScriptReference/Plane-ctor.html</a> 可以查到 Plane 的 constructor 是長這樣： <code>Plane (Vector3 inNormal, float distance)</code> 。</p><p>以三維座標 (0, 0, 0) 為基準點，基於法線方向 <code>inNormal</code> 在距離基準點 <code>distance</code> 的位置創造一個平面。 <code>Vector3.up</code> 就等於 <code>Vector3 (0, 1, 0)</code> ，也就是筆直朝向 Y 軸上方的向量。這個 plane 不會顯示在遊戲中，如果想要用視覺理解 plane 的概念，可以直接在 Editor 中新增一個 rotation 與 position 都為 (0, 0, 0) 的 Plane，這兩個平面基本上相同。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#B57614">   Camera</span><span style="color:#427B58"> camera</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">   Vector3</span><span style="color:#427B58"> mousePos</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">   void</span><span style="color:#79740E"> Start</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">       camera</span><span style="color:#427B58"> =</span><span style="color:#076678"> Camera</span><span style="color:#7C6F64">.</span><span style="color:#076678">main</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">   }</span></span></code></pre></div><p>將目前使用的主攝影機存為變數，並預先設立儲存滑鼠位置用的變數。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#9D0006">void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#9D0006">    float</span><span style="color:#427B58"> distance</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Ray</span><span style="color:#427B58"> ray</span><span style="color:#427B58"> =</span><span style="color:#076678"> camera</span><span style="color:#7C6F64">.</span><span style="color:#79740E">ScreenPointToRay</span><span style="color:#7C6F64">(</span><span style="color:#076678">Input</span><span style="color:#7C6F64">.</span><span style="color:#076678">mousePosition</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#427B58">    ..</span><span style="color:#3C3836">.</span></span></code></pre></div><p>在每次更新時，創建一個空的距離變數 <code>distance</code> ，以及一個射線變數 <code>ray</code> ，起點為攝影機的 near clipping plane，方向為滑鼠位置。</p><p>攝影機的顯示範圍是一個上窄下寬的梯形，頂部距離攝影機較近且面積較小的平面就是 near clipping plane，底部較遠較大的平面就是 far clipping plane。玩家所謂的遊戲視窗大小基本上就等於 near clipping plane， <code>Camera.ScreenPointToRay</code> 也就是從 near clipping plane 射向 far clipping plane。</p><figure><img src="/public/images/blog/unity-dev-memo-1_1.png" alt=""></figure><p>這兩個數值都可以從 camera 的 inspector 調整。</p><figure><img src="/public/images/blog/unity-dev-memo-1_2.png" alt=""></figure><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#427B58">		..</span><span style="color:#3C3836">.</span></span>
<span class="line"><span style="color:#9D0006">		if</span><span style="color:#7C6F64">(</span><span style="color:#076678">plane</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Raycast</span><span style="color:#7C6F64">(</span><span style="color:#427B58">ray</span><span style="color:#7C6F64">,</span><span style="color:#AF3A03"> out</span><span style="color:#427B58"> distance</span><span style="color:#7C6F64">)){</span></span>
<span class="line"><span style="color:#427B58">        mousePos</span><span style="color:#427B58"> =</span><span style="color:#076678"> ray</span><span style="color:#7C6F64">.</span><span style="color:#79740E">GetPoint</span><span style="color:#7C6F64">(</span><span style="color:#427B58">distance</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"><span style="color:#3C3836">}</span></span></code></pre></div><p>回到程式碼， <code>plane.Raycast</code> 中的 <code>out</code> 是另一個值得注意的地方。先看 <code>plane.Raycast</code> 函數本身：</p><p><a href="https://docs.unity3d.com/ScriptReference/Plane.Raycast.html" target="_blank" rel="noopener noreferrer">https://docs.unity3d.com/ScriptReference/Plane.Raycast.html</a></p><p>這個函數的型別是 bool ，回傳引數 ray 是否與該 plane 相交。然而，部分函數提供額外的回傳值，取得值時必須提供一個空變數與 <code>out</code> 關鍵字一起作為引數輸入。 <code>plane.Raycast</code> 就是有提供 <code>out</code> 回傳值的函數之一，提供的是當相交發生時從 ray 起點至相交點的距離 <code>distance</code> 。因此這一段程式碼的作用是，判斷平面 plane 與 ray 是否有相交發生，如果有的話將距離儲存進 distance。現在射線起點，相交距離都知道了，就能計算出滑鼠位置便是從該射線上從起點開始距離 distance 的地方。</p><figure><img src="/public/images/blog/unity-dev-memo-2_3.gif" alt=""></figure><p>以上就是在射線上增加元素使其可視化之後的展示，紅色點是射線起點 (<code>ray.GetPoint(0)</code> )，藍色點是與平面相交點（ <code>ray.GetPoint(distance)</code> ）。可以看見起點不是攝影機本身，而是在 near clipping plane 上。</p><h3>Collider.Raycast</h3><p>以上都是純平面的情況，實際在遊戲中常常有地形非單純平面的情況，此時可以使用 <code>TerrainCollider</code> 來計算射線與地形 terrain 的相交點。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Generic</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> UnityEngine</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AF3A03">public</span><span style="color:#AF3A03"> class</span><span style="color:#B57614"> GetMousePos</span><span style="color:#7C6F64"> :</span><span style="color:#B57614"> MonoBehaviour</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">    TerrainCollider</span><span style="color:#427B58"> terrainCollider</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Camera</span><span style="color:#427B58"> camera</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Vector3</span><span style="color:#427B58"> mousePos</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Start</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">        camera</span><span style="color:#427B58"> =</span><span style="color:#076678"> Camera</span><span style="color:#7C6F64">.</span><span style="color:#076678">main</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#427B58">        terrainCollider</span><span style="color:#427B58"> =</span><span style="color:#076678"> Terrain</span><span style="color:#7C6F64">.</span><span style="color:#076678">activeTerrain</span><span style="color:#7C6F64">.</span><span style="color:#79740E">GetComponent</span><span style="color:#7C6F64">&lt;</span><span style="color:#B57614">TerrainCollider</span><span style="color:#7C6F64">&gt;();</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">        Ray</span><span style="color:#427B58"> ray</span><span style="color:#427B58"> =</span><span style="color:#076678"> camera</span><span style="color:#7C6F64">.</span><span style="color:#79740E">ScreenPointToRay</span><span style="color:#7C6F64">(</span><span style="color:#076678">Input</span><span style="color:#7C6F64">.</span><span style="color:#076678">mousePosition</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#B57614">        RaycastHit</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">        if</span><span style="color:#7C6F64">(</span><span style="color:#076678">terrainCollider</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Raycast</span><span style="color:#7C6F64">(</span><span style="color:#427B58">ray</span><span style="color:#7C6F64">,</span><span style="color:#AF3A03"> out</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 1000</span><span style="color:#7C6F64">)){</span></span>
<span class="line"><span style="color:#427B58">            mousePos</span><span style="color:#427B58"> =</span><span style="color:#076678"> hitData</span><span style="color:#7C6F64">.</span><span style="color:#076678">point</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">        }</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"><span style="color:#7C6F64">}</span></span></code></pre></div><p>內容大致相同，只是這次判斷相交點的元素不是平面，而是地形碰撞體 <code>terrainCollider</code> ，而這個函數所提供的 out 相交資料也更豐富，不只有距離，而是一整個資料形態 RaycastHit <a href="https://docs.unity3d.com/ScriptReference/RaycastHit.html" target="_blank" rel="noopener noreferrer">https://docs.unity3d.com/ScriptReference/RaycastHit.html</a> ，包含 point, distance ,collider 等，point 即為射線與 <code>terrainCollider</code> 相交點。</p><figure><img src="/public/images/blog/unity-dev-memo-2_4.gif" alt=""></figure><p>上圖就是在不規則地形使用 <code>terrainCollider.Raycast</code> 追蹤游標位置的展示，可以看見在右側遊戲畫面中游標移至山脈可見的南側時，左側的編輯器畫面也顯示游標位置的藍點直接跳過山脈北側，同時隨著地形一同起伏。</p><h3>Physics.Raycast</h3><p>以上兩種實作的前提都是射線相交的對象為特定單一物件。想要判斷射線是否相交非特定物件時，使用 <code>Physics.Raycast</code> 。這個函數會抓取引數的射線相交的第一個對象，且同樣提供 <code>out RaycastHit</code> 資料。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Generic</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> UnityEngine</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AF3A03">public</span><span style="color:#AF3A03"> class</span><span style="color:#B57614"> GetMousePos</span><span style="color:#7C6F64"> :</span><span style="color:#B57614"> MonoBehaviour</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">    Camera</span><span style="color:#427B58"> camera</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Vector3</span><span style="color:#427B58"> mousePos</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Start</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">        camera</span><span style="color:#427B58"> =</span><span style="color:#076678"> Camera</span><span style="color:#7C6F64">.</span><span style="color:#076678">main</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">        Ray</span><span style="color:#427B58"> ray</span><span style="color:#427B58"> =</span><span style="color:#076678"> camera</span><span style="color:#7C6F64">.</span><span style="color:#79740E">ScreenPointToRay</span><span style="color:#7C6F64">(</span><span style="color:#076678">Input</span><span style="color:#7C6F64">.</span><span style="color:#076678">mousePosition</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#B57614">        RaycastHit</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">        if</span><span style="color:#7C6F64">(</span><span style="color:#076678">Physics</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Raycast</span><span style="color:#7C6F64">(</span><span style="color:#427B58">ray</span><span style="color:#7C6F64">,</span><span style="color:#AF3A03"> out</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 1000</span><span style="color:#7C6F64">)){</span></span>
<span class="line"><span style="color:#427B58">            mousePos</span><span style="color:#427B58"> =</span><span style="color:#076678"> hitData</span><span style="color:#7C6F64">.</span><span style="color:#076678">point</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">						GameObject</span><span style="color:#427B58"> hitObj</span><span style="color:#427B58"> =</span><span style="color:#076678"> hitData</span><span style="color:#7C6F64">.</span><span style="color:#076678">collider</span><span style="color:#7C6F64">.</span><span style="color:#076678">transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">gameObject</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">        }</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"><span style="color:#7C6F64">}</span></span></code></pre></div><p><code>Physics.Raycast</code> 的提供距離引數做為判斷相交的最大距離，可以依照自己需求設定。</p><figure><img src="/public/images/blog/unity-dev-memo-2_5 1.gif" alt=""></figure><p>上圖為使用 <code>Physics.Raycast</code> 追蹤游標互動物件的展示，使用 <code>RaycastHit.collider.transform.GameObject</code> 判斷射線的碰撞體的原物件之後就可以進行互動。</p><h3>LayerMask in Physics.Raycast</h3><p><code>Physics.Raycast</code> 還提供圖層引數過濾判斷射線相交對象。</p><div><pre class="shiki gruvbox-light-soft" style="background-color:#f2e5bc;color:#3c3836" tabindex="0"><code><span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> System</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Collections</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Generic</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">using</span><span style="color:#79740E"> UnityEngine</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AF3A03">public</span><span style="color:#AF3A03"> class</span><span style="color:#B57614"> HighlightRayOrigin</span><span style="color:#7C6F64"> :</span><span style="color:#B57614"> MonoBehaviour</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">    Camera</span><span style="color:#427B58"> camera</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    Vector3</span><span style="color:#427B58"> mousePos</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">    LayerMask</span><span style="color:#427B58"> layerMask</span><span style="color:#427B58"> =</span><span style="color:#8F3F71"> 1</span><span style="color:#427B58"> &lt;&lt;</span><span style="color:#8F3F71"> 8</span><span style="color:#7C6F64">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Start</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">        camera</span><span style="color:#427B58"> =</span><span style="color:#076678"> Camera</span><span style="color:#7C6F64">.</span><span style="color:#076678">main</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9D0006">    void</span><span style="color:#79740E"> Update</span><span style="color:#7C6F64"> ()</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#B57614">        Ray</span><span style="color:#427B58"> ray</span><span style="color:#427B58"> =</span><span style="color:#076678"> camera</span><span style="color:#7C6F64">.</span><span style="color:#79740E">ScreenPointToRay</span><span style="color:#7C6F64"> (</span><span style="color:#076678">Input</span><span style="color:#7C6F64">.</span><span style="color:#076678">mousePosition</span><span style="color:#7C6F64">);</span></span>
<span class="line"><span style="color:#B57614">        RaycastHit</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#9D0006">        if</span><span style="color:#7C6F64"> (</span><span style="color:#076678">Physics</span><span style="color:#7C6F64">.</span><span style="color:#79740E">Raycast</span><span style="color:#7C6F64"> (</span><span style="color:#427B58">ray</span><span style="color:#7C6F64">,</span><span style="color:#AF3A03"> out</span><span style="color:#427B58"> hitData</span><span style="color:#7C6F64">,</span><span style="color:#8F3F71"> 1000</span><span style="color:#7C6F64">,</span><span style="color:#427B58"> layerMask</span><span style="color:#7C6F64">))</span><span style="color:#7C6F64"> {</span></span>
<span class="line"><span style="color:#427B58">            mousePos</span><span style="color:#427B58"> =</span><span style="color:#076678"> hitData</span><span style="color:#7C6F64">.</span><span style="color:#076678">point</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#B57614">						GameObject</span><span style="color:#427B58"> hitObj</span><span style="color:#427B58"> =</span><span style="color:#076678"> hitData</span><span style="color:#7C6F64">.</span><span style="color:#076678">collider</span><span style="color:#7C6F64">.</span><span style="color:#076678">transform</span><span style="color:#7C6F64">.</span><span style="color:#076678">gameObject</span><span style="color:#7C6F64">;</span></span>
<span class="line"><span style="color:#7C6F64">        }</span></span>
<span class="line"><span style="color:#7C6F64">    }</span></span>
<span class="line"><span style="color:#7C6F64">}</span></span></code></pre></div><p><code>Physics.Raycast</code> 的 <code>layerMask</code> 引數就是指定圖層，只有在這個圖層中的物件才會觸發與射線相交的判斷。</p><p>請注意，雖然這個引數的型別是 int，但其實是二進制的 int，所以直接輸入在編輯器中顯示的圖層編號是不會正常運作的，必須以 <code>&lt;&lt;</code> 運算子將指定編號以二進制方式儲存在變數中再傳遞給 <code>Physics.Raycast</code> 函數。</p><figure><img src="/public/images/blog/unity-dev-memo-2_6.gif" alt=""></figure><p>上圖是使用 LayerMask 過濾可互動物件的展示，只有上層物件位於可互動的圖層中，因此游標在地形或是下層物件時藍點都不會隨之移動。</p></article></main><footer class="site-footer_container">Asuka Wang © <!-- -->2025</footer></div></div></div><script>window.__STATIC_PROPS__ = {"blog":{"post":{"metadata":{"title":"Unity Dev Memo (2)","description":"關於 Unity3D 內 raycast 的研究筆記。","publishedAt":"2020-10-04","pathname":"unity-dev-memo-2","category":"note","topic":"game development","language":"zh-TW","featured":false},"content":[{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Raycast"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"在使用滑鼠的 3D 遊戲中，幾乎與任何物件互動都需要使用滑鼠，判斷玩家游標的位置自然是非常重要且基礎的技術。然而相對 3D 世界的三維座標，存在於螢幕上的游標只有二維座標的 X 軸與 Y 軸兩個數據代表位置，這使得在遊戲世界中精準定位游標位置變得困難。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"不過，大多數想要在遊戲中取得游標位置時，都是為了與存在該位置的物件互動。這個物件就能成為定位游標的輔助工具，只要計算從玩家視角中的游標，是否真正與遊戲世界中的該物件重合即可。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"具體來說，這個判斷方式是從攝影機朝向滑鼠的二維座標射出一道直線，並判斷該射線所相交的物件。"}]},{"type":"heading","level":3,"body":[{"type":"textBody","style":"plain","value":"Plane.Raycast"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"先從這個技術的最基本實作，也就是判斷滑鼠在純平面上的座標開始。"}]},{"type":"code","lang":"csharp","body":"using UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Plane plane = new Plane (Vector3.up, 0);\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        float distance;\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        if(plane.Raycast(ray, out distance)){\n            mousePos = ray.GetPoint(distance);\n        }\n    }\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"一行一行解讀："}]},{"type":"code","lang":"csharp","body":"Plane plane = new Plane (Vector3.up, 0);"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"從官方文件 "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"https://docs.unity3d.com/ScriptReference/Plane-ctor.html"}],"url":"https://docs.unity3d.com/ScriptReference/Plane-ctor.html"},{"type":"textBody","style":"plain","value":" 可以查到 Plane 的 constructor 是長這樣： "},{"type":"textBody","style":"code","value":"Plane (Vector3 inNormal, float distance)"},{"type":"textBody","style":"plain","value":" 。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"以三維座標 (0, 0, 0) 為基準點，基於法線方向 "},{"type":"textBody","style":"code","value":"inNormal"},{"type":"textBody","style":"plain","value":" 在距離基準點 "},{"type":"textBody","style":"code","value":"distance"},{"type":"textBody","style":"plain","value":" 的位置創造一個平面。 "},{"type":"textBody","style":"code","value":"Vector3.up"},{"type":"textBody","style":"plain","value":" 就等於 "},{"type":"textBody","style":"code","value":"Vector3 (0, 1, 0)"},{"type":"textBody","style":"plain","value":" ，也就是筆直朝向 Y 軸上方的向量。這個 plane 不會顯示在遊戲中，如果想要用視覺理解 plane 的概念，可以直接在 Editor 中新增一個 rotation 與 position 都為 (0, 0, 0) 的 Plane，這兩個平面基本上相同。"}]},{"type":"code","lang":"csharp","body":"   Camera camera;\n   Vector3 mousePos;\n   void Start () {\n       camera = Camera.main;\n   }"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"將目前使用的主攝影機存為變數，並預先設立儲存滑鼠位置用的變數。"}]},{"type":"code","lang":"csharp","body":"void Update () {\n    float distance;\n    Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n    ..."},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"在每次更新時，創建一個空的距離變數 "},{"type":"textBody","style":"code","value":"distance"},{"type":"textBody","style":"plain","value":" ，以及一個射線變數 "},{"type":"textBody","style":"code","value":"ray"},{"type":"textBody","style":"plain","value":" ，起點為攝影機的 near clipping plane，方向為滑鼠位置。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"攝影機的顯示範圍是一個上窄下寬的梯形，頂部距離攝影機較近且面積較小的平面就是 near clipping plane，底部較遠較大的平面就是 far clipping plane。玩家所謂的遊戲視窗大小基本上就等於 near clipping plane， "},{"type":"textBody","style":"code","value":"Camera.ScreenPointToRay"},{"type":"textBody","style":"plain","value":" 也就是從 near clipping plane 射向 far clipping plane。"}]},{"type":"image","url":"unity-dev-memo-1_1.png","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"這兩個數值都可以從 camera 的 inspector 調整。"}]},{"type":"image","url":"unity-dev-memo-1_2.png","altText":"","caption":""},{"type":"code","lang":"csharp","body":"\t\t...\n\t\tif(plane.Raycast(ray, out distance)){\n        mousePos = ray.GetPoint(distance);\n    }\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"回到程式碼， "},{"type":"textBody","style":"code","value":"plane.Raycast"},{"type":"textBody","style":"plain","value":" 中的 "},{"type":"textBody","style":"code","value":"out"},{"type":"textBody","style":"plain","value":" 是另一個值得注意的地方。先看 "},{"type":"textBody","style":"code","value":"plane.Raycast"},{"type":"textBody","style":"plain","value":" 函數本身："}]},{"type":"paragraph","body":[{"type":"link","body":[{"type":"textBody","style":"plain","value":"https://docs.unity3d.com/ScriptReference/Plane.Raycast.html"}],"url":"https://docs.unity3d.com/ScriptReference/Plane.Raycast.html"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"這個函數的型別是 bool ，回傳引數 ray 是否與該 plane 相交。然而，部分函數提供額外的回傳值，取得值時必須提供一個空變數與 "},{"type":"textBody","style":"code","value":"out"},{"type":"textBody","style":"plain","value":" 關鍵字一起作為引數輸入。 "},{"type":"textBody","style":"code","value":"plane.Raycast"},{"type":"textBody","style":"plain","value":" 就是有提供 "},{"type":"textBody","style":"code","value":"out"},{"type":"textBody","style":"plain","value":" 回傳值的函數之一，提供的是當相交發生時從 ray 起點至相交點的距離 "},{"type":"textBody","style":"code","value":"distance"},{"type":"textBody","style":"plain","value":" 。因此這一段程式碼的作用是，判斷平面 plane 與 ray 是否有相交發生，如果有的話將距離儲存進 distance。現在射線起點，相交距離都知道了，就能計算出滑鼠位置便是從該射線上從起點開始距離 distance 的地方。"}]},{"type":"image","url":"unity-dev-memo-2_3.gif","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"以上就是在射線上增加元素使其可視化之後的展示，紅色點是射線起點 ("},{"type":"textBody","style":"code","value":"ray.GetPoint(0)"},{"type":"textBody","style":"plain","value":" )，藍色點是與平面相交點（ "},{"type":"textBody","style":"code","value":"ray.GetPoint(distance)"},{"type":"textBody","style":"plain","value":" ）。可以看見起點不是攝影機本身，而是在 near clipping plane 上。"}]},{"type":"heading","level":3,"body":[{"type":"textBody","style":"plain","value":"Collider.Raycast"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"以上都是純平面的情況，實際在遊戲中常常有地形非單純平面的情況，此時可以使用 "},{"type":"textBody","style":"code","value":"TerrainCollider"},{"type":"textBody","style":"plain","value":" 來計算射線與地形 terrain 的相交點。"}]},{"type":"code","lang":"csharp","body":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    TerrainCollider terrainCollider;\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n        terrainCollider = Terrain.activeTerrain.GetComponent\u003cTerrainCollider\u003e();\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(terrainCollider.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n        }\n    }\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"內容大致相同，只是這次判斷相交點的元素不是平面，而是地形碰撞體 "},{"type":"textBody","style":"code","value":"terrainCollider"},{"type":"textBody","style":"plain","value":" ，而這個函數所提供的 out 相交資料也更豐富，不只有距離，而是一整個資料形態 RaycastHit "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"https://docs.unity3d.com/ScriptReference/RaycastHit.html"}],"url":"https://docs.unity3d.com/ScriptReference/RaycastHit.html"},{"type":"textBody","style":"plain","value":" ，包含 point, distance ,collider 等，point 即為射線與 "},{"type":"textBody","style":"code","value":"terrainCollider"},{"type":"textBody","style":"plain","value":" 相交點。"}]},{"type":"image","url":"unity-dev-memo-2_4.gif","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"上圖就是在不規則地形使用 "},{"type":"textBody","style":"code","value":"terrainCollider.Raycast"},{"type":"textBody","style":"plain","value":" 追蹤游標位置的展示，可以看見在右側遊戲畫面中游標移至山脈可見的南側時，左側的編輯器畫面也顯示游標位置的藍點直接跳過山脈北側，同時隨著地形一同起伏。"}]},{"type":"heading","level":3,"body":[{"type":"textBody","style":"plain","value":"Physics.Raycast"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"以上兩種實作的前提都是射線相交的對象為特定單一物件。想要判斷射線是否相交非特定物件時，使用 "},{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 。這個函數會抓取引數的射線相交的第一個對象，且同樣提供 "},{"type":"textBody","style":"code","value":"out RaycastHit"},{"type":"textBody","style":"plain","value":" 資料。"}]},{"type":"code","lang":"csharp","body":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(Physics.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n\t\t\t\t\t\tGameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 的提供距離引數做為判斷相交的最大距離，可以依照自己需求設定。"}]},{"type":"image","url":"unity-dev-memo-2_5 1.gif","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"上圖為使用 "},{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 追蹤游標互動物件的展示，使用 "},{"type":"textBody","style":"code","value":"RaycastHit.collider.transform.GameObject"},{"type":"textBody","style":"plain","value":" 判斷射線的碰撞體的原物件之後就可以進行互動。"}]},{"type":"heading","level":3,"body":[{"type":"textBody","style":"plain","value":"LayerMask in Physics.Raycast"}]},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 還提供圖層引數過濾判斷射線相交對象。"}]},{"type":"code","lang":"csharp","body":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class HighlightRayOrigin : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n    LayerMask layerMask = 1 \u003c\u003c 8;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay (Input.mousePosition);\n        RaycastHit hitData;\n        if (Physics.Raycast (ray, out hitData, 1000, layerMask)) {\n            mousePos = hitData.point;\n\t\t\t\t\t\tGameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 的 "},{"type":"textBody","style":"code","value":"layerMask"},{"type":"textBody","style":"plain","value":" 引數就是指定圖層，只有在這個圖層中的物件才會觸發與射線相交的判斷。"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"請注意，雖然這個引數的型別是 int，但其實是二進制的 int，所以直接輸入在編輯器中顯示的圖層編號是不會正常運作的，必須以 "},{"type":"textBody","style":"code","value":"\u003c\u003c"},{"type":"textBody","style":"plain","value":" 運算子將指定編號以二進制方式儲存在變數中再傳遞給 "},{"type":"textBody","style":"code","value":"Physics.Raycast"},{"type":"textBody","style":"plain","value":" 函數。"}]},{"type":"image","url":"unity-dev-memo-2_6.gif","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"上圖是使用 LayerMask 過濾可互動物件的展示，只有上層物件位於可互動的圖層中，因此游標在地形或是下層物件時藍點都不會隨之移動。"}]}]}}}</script>
  

<script>(function(){var el=document.createElement('link');el.href='/subfont/fallback-6f3457f228.css';el.rel='stylesheet';document.body.appendChild(el)}())</script><noscript><link rel="stylesheet" href="/subfont/fallback-6f3457f228.css"></noscript></body></html>